/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HorizontalBlocksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var HorizontalBlockRenderer = class extends import_obsidian.MarkdownRenderChild {
  constructor(containerEl, plugin, source, sourcePath) {
    super(containerEl);
    __publicField(this, "plugin");
    __publicField(this, "source");
    __publicField(this, "sourcePath");
    this.plugin = plugin;
    this.source = source;
    this.sourcePath = sourcePath;
  }
  async onload() {
    const container = this.containerEl;
    container.className = "horizontal-block-container";
    const blockId = await this.plugin.hashString(this.source);
    const savedLayout = this.plugin.settings[`horizontal-block-layout-${blockId}`] || {};
    const sections = this.source.split(/^---$/m).map((part) => part.trim());
    const blocks = [];
    for (let index = 0; index < sections.length; index++) {
      const markdown = sections[index];
      const block = await this.createRenderedBlock(markdown, savedLayout[`title-${index}`]);
      const savedWidth = savedLayout[`width-${index}`];
      if (savedWidth) {
        block.classList.add("horizontal-block-flex-fixed");
        this.plugin.applyBlockWidth(block, savedWidth);
      } else {
        block.classList.add("horizontal-block-flex-grow");
      }
      blocks.push(block);
    }
    for (let i = 0; i < blocks.length; i++) {
      container.appendChild(blocks[i]);
      if (i < blocks.length - 1) {
        const resizer = document.createElement("div");
        resizer.className = "horizontal-block-resizer";
        container.appendChild(resizer);
        this.makeResizable(blocks[i], blocks[i + 1], resizer, blockId, i);
      }
    }
  }
  async createRenderedBlock(markdown, title) {
    const block = document.createElement("div");
    block.className = "resizable-block";
    if (title) {
      const header = document.createElement("div");
      header.className = "block-title";
      header.innerText = title;
      block.appendChild(header);
    }
    const preview = document.createElement("div");
    preview.className = "horizontal-block-md-preview";
    preview.classList.add("markdown-rendered");
    await import_obsidian.MarkdownRenderer.render(this.plugin.app, markdown, preview, this.sourcePath, this);
    const images = preview.querySelectorAll("img");
    images.forEach((img) => {
      img.classList.add("horizontal-block-image");
    });
    block.appendChild(preview);
    return block;
  }
  makeResizable(left, right, resizer, blockId, index) {
    let isResizing = false;
    let startX = 0;
    let startLeftWidth = 0;
    let mouseMoveListener = null;
    let mouseUpListener = null;
    const mouseDownHandler = (e) => {
      isResizing = true;
      startX = e.clientX;
      startLeftWidth = left.getBoundingClientRect().width;
      document.body.classList.add("horizontal-block-resizing-cursor");
      left.classList.add("horizontal-block-flex-fixed");
      left.classList.remove("horizontal-block-flex-grow");
      right.classList.add("horizontal-block-flex-grow");
      right.classList.remove("horizontal-block-flex-fixed");
      mouseMoveListener = (e2) => {
        if (!isResizing) return;
        const dx = e2.clientX - startX;
        const newLeftWidth = startLeftWidth + dx;
        left.classList.add("horizontal-block-flex-fixed");
        left.classList.remove("horizontal-block-flex-grow");
        this.plugin.applyBlockWidth(left, newLeftWidth);
        right.classList.add("horizontal-block-flex-grow");
        right.classList.remove("horizontal-block-flex-fixed");
        this.plugin.removeBlockWidth(right);
      };
      mouseUpListener = async () => {
        isResizing = false;
        document.body.classList.remove("horizontal-block-resizing-cursor");
        if (mouseMoveListener) {
          document.removeEventListener("mousemove", mouseMoveListener);
          mouseMoveListener = null;
        }
        if (mouseUpListener) {
          document.removeEventListener("mouseup", mouseUpListener);
          mouseUpListener = null;
        }
        const finalWidth = left.getBoundingClientRect().width;
        const layoutKey = `horizontal-block-layout-${blockId}`;
        if (!this.plugin.settings[layoutKey]) this.plugin.settings[layoutKey] = {};
        this.plugin.settings[layoutKey][`width-${index}`] = finalWidth;
        await this.plugin.saveData(this.plugin.settings);
      };
      document.addEventListener("mousemove", mouseMoveListener);
      document.addEventListener("mouseup", mouseUpListener);
    };
    this.registerDomEvent(resizer, "mousedown", mouseDownHandler);
  }
};
var HorizontalBlocksPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings", {});
    __publicField(this, "styleEl");
  }
  async onload() {
    this.settings = await this.loadData() || {};
    this.registerMarkdownCodeBlockProcessor("horizontal", async (source, el, ctx) => {
      const renderer = new HorizontalBlockRenderer(el, this, source, ctx.sourcePath);
      ctx.addChild(renderer);
    });
  }
  onunload() {
  }
  async hashString(str) {
    const buffer = new TextEncoder().encode(str);
    const digest = await crypto.subtle.digest("SHA-256", buffer);
    return Array.from(new Uint8Array(digest)).map((x) => x.toString(16).padStart(2, "0")).join("").slice(0, 16);
  }
  applyBlockWidth(block, width) {
    block.classList.add("has-width");
    block.setAttribute("style", `--block-width: ${Math.round(width)}px`);
  }
  removeBlockWidth(block) {
    block.classList.remove("has-width");
    block.removeAttribute("style");
  }
};


/* nosourcemap */